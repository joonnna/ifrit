package ifrit

import (
	"errors"

	"github.com/joonnna/ifrit/core"
	"github.com/joonnna/ifrit/rpc"
	"github.com/spf13/viper"
)

type Client struct {
	node *core.Node
}

var (
	errNoData      = errors.New("Supplied data is of length 0")
	errNoCaAddress = errors.New("Config does not contain address of CA")
)

/*
	Alternative to registrating callbacks
	type MsgHandler interface {
		HandleMsg([]byte) ([]byte, error)
		HandleGossip([]byte) ([]byte, error)
		ResponseHandler([]byte) []byte
	}
*/

// Creates and returns a new ifrit client instance.
// Passing an empty config struct or nil will result in all defaults, see config documentation for config description.
func NewClient() (*Client, error) {
	err := readConfig()
	if err != nil {
		return nil, err
	}

	c := rpc.NewClient()

	s, err := rpc.NewServer()
	if err != nil {
		return nil, err
	}

	n, err := core.NewNode(c, s)
	if err != nil {
		return nil, err
	}

	client := &Client{
		node: n,
	}

	return client, nil
}

// Registers the given function as the message handler.
// Invoked each time the ifrit client receives an application specific message(another client sent it through SendTo/SendToAll), this callback will be invoked.a
// The returned byte slice will be sent back as the response.
// If error is non-nil, it will be returned as the response.
// All responses will be received on the sending side through a channel,
// see SendTo/SendToAll documentation for details.
func (c *Client) RegisterMsgHandler(msgHandler func([]byte) ([]byte, error)) {
	c.node.SetMsgHandler(msgHandler)
}

// Registers the given function as the message handler.
// Invoked each time ifrit receives application gossip.
// The returned byte slice will be sent back as the response.
// If the callback returns a non-nil error, it will be sent back as the response.
// The provided response will be the argument to the callback registered as ResponseHandler.
func (c *Client) RegisterGossipHandler(gossipHandler func([]byte) ([]byte, error)) {
	c.node.SetGossipHandler(gossipHandler)
}

// Registers the given function as the gossip response handler.
// Invoked when ifrit receives a response after gossiping application data.
// All responses originates from a gossip handler invocation.
// If the ResponseHandler is not registered or nil, responses will be discarded.
func (c *Client) RegisterResponseHandler(responseHandler func([]byte)) {
	c.node.SetResponseHandler(responseHandler)
}

// Shutsdown the client and all held resources.
func (c *Client) ShutDown() {
	c.node.ShutDownNode()
}

// Client starts operating.
func (c *Client) Start() {
	c.node.Start()
}

// Returns the address(ip:port, rpc endpoint) of all other ifrit clients in the network which is currently
// believed to be alive.
func (c *Client) Members() []string {
	return c.node.LiveMembers()
}

// Sends the given data to the given destination.
// The caller must ensure that the given data is not modified after calling this function.
// The returned channel will be populated with the response.
// If the destination could not be reached or timeout occurs, nil will be sent through the channel.
// The response data can be safely modified after receiving it.
func (c *Client) SendTo(dest string, data []byte) chan []byte {
	ch := make(chan []byte, 1)

	go c.node.SendMessage(dest, ch, data)

	return ch
}

// Same as SendTo, but destination is now the Ifrit id of the receiver.
// Returns an error if no observed peer has the specified  destination id.
func (c *Client) SendToId(destId []byte, data []byte) (chan []byte, error) {
	addr, err := c.node.IdToAddr(destId)
	if err != nil {
		return nil, err
	}

	ch := make(chan []byte, 1)

	go c.node.SendMessage(addr, ch, data)

	return ch, err
}

// Sends the given data to all members of the network belivied to be alive.
// The returned channel functions as described in SendTo().
// The returned integer represents the amount of members the message was sent to.
func (c *Client) SendToAll(data []byte) (chan []byte, int) {
	members := c.node.LiveMembers()

	numMembers := len(members)

	//Don't want channel to be too big.
	chSize := int(float32(numMembers) * 0.10)

	if chSize <= 0 {
		chSize = 1
	}

	ch := make(chan []byte, chSize)

	go c.node.SendMessages(members, ch, data)

	return ch, numMembers
}

// Replaces the gossip set with the given data.
// This data will be exchanged with neighbors in each gossip interaction.
// Recipients will receive it through the message handler callback.
// The response generated by the message handler callback will be sent back and
// invoke the response handler callback.
func (c *Client) SetGossipContent(data []byte) error {
	if len(data) <= 0 {
		return errNoData
	}

	c.node.SetExternalGossipContent(data)

	return nil
}

// Returns ifrit's internal ID generated by the trusted CA
func (c *Client) Id() string {
	return c.node.Id()
}

// Returns the address(ip:port) of the ifrit client.
// Can be directly used as entry addresses in the config.
func (c *Client) Addr() string {
	return c.node.Addr()
}

// Returns the address(ip:port) of the ifrit http endpoint.
// Only used for debuging, populated if visualizer is enabled..
func (c *Client) HttpAddr() string {
	return c.node.HttpAddr()
}

// Returns the address(ip:port, http endpoint) of all members of the fireflies
// network believed to be alive.
// Only used for debuging, populated if visualizer is enabled.
func (c *Client) MembersHttp() []string {
	return c.node.LiveMembersHttp()
}

// Starts recording amount of gossip rounds, used for experiments.
func (c *Client) RecordGossipRounds() {
	c.node.StartGossipRecording()
}

// Returns the amount of gossip rounds since recording started.
func (c *Client) GetGossipRounds() uint32 {
	return c.node.GetGossipRounds()
}

// Signs the provided content with the internal private key of ifrit.
func (c *Client) Sign(content []byte) ([]byte, []byte, error) {
	return c.node.Sign(content)
}

// Checks if the given content is correctly signed by the public key
// belonging to the given node id.
// The id represents another node in the Fireflies network, if the id
// is not recongnized false is returned.
func (c *Client) VerifySignature(r, s, content []byte, id string) bool {
	return c.node.Verify(r, s, content, id)
}

func readConfig() error {
	viper.SetConfigName("ifrit_config")
	viper.AddConfigPath("/var/tmp/ifrit")
	viper.AddConfigPath(".")

	viper.SetConfigType("yaml")

	err := viper.ReadInConfig()
	if err != nil {
		return err
	}

	// Behavior variables
	viper.SetDefault("gossip_interval", 10)
	viper.SetDefault("monitor_interval", 10)
	viper.SetDefault("ping_limit", 3)
	viper.SetDefault("removal_timeout", 60)
	viper.SetDefault("max_concurrent_messages", 50)

	// Visualizer specific
	viper.SetDefault("viz_update_interval", 10)

	viper.SafeWriteConfig()

	return nil
}
